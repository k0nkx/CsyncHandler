-- Csync Handler Module
-- Author: Desync Module
-- Version: 1.0
-- Usage: local Csync = loadstring(game:HttpGet("YOUR_SCRIPT_URL"))()

-- Services
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local Camera = workspace.CurrentCamera
local CoreGui = game:GetService("CoreGui")
local Stats = game:GetService("Stats")

-- Module table
local Csync = {}

-- Internal state
Csync._Enabled = false
Csync._Connections = {}
Csync._Instances = {}
Csync._Drawings = {}
Csync._PositionHistory = {}
Csync._OriginalCFrameIndex = nil
Csync._LockUntil = 0
Csync._LockPosition = nil
Csync._Keybind = Enum.KeyCode.V
Csync._Config = {
    Position = {
        X = 0,
        Y = 5,
        Z = 0
    },
    UseServerPrediction = true,
    ServerPrediction = {
        HistoryDuration = 2,
        MaxPing = 300,
        HighPingThreshold = 160,
        HighPingReduction = 0.9
    },
    Visuals = {
        DesyncColor = Color3.fromRGB(0, 162, 255),
        Transparency = 0,
        ShowLine = true,
        Line = {
            MainColor = Color3.fromRGB(255, 255, 255),
            OutlineColor = Color3.fromRGB(0, 0, 0),
            MainThickness = 2,
            OutlineThickness = 3,
            MainTransparency = 1,
            OutlineTransparency = 1,
            Extension = 1
        },
        VisualType = "Both", -- "Mesh", "Image", "Both", "None"
        MeshId = "rbxassetid://14123716423",
        MeshScale = Vector3.new(0.1, 0.1, 0.1),
        MeshOffset = Vector3.new(0, -0.8, 0),
        ImageId = "rbxassetid://94277058488615",
        ImageScale = 0.38,
        Highlight = {
            Enabled = true,
            FillColor = Color3.fromRGB(245, 173, 255),
            OutlineColor = Color3.fromRGB(255, 255, 255),
            FillTransparency = 0.7,
            OutlineTransparency = 0.5,
            DepthMode = "AlwaysOnTop"
        }
    }
}

-- Player references
local player = Players.LocalPlayer
local playerCharacter = player.Character or player.CharacterAdded:Wait()
local playerHumanoid = playerCharacter:WaitForChild("Humanoid")
local playerHumanoidRootPart = playerCharacter:WaitForChild("HumanoidRootPart")
local playerHumanoidRootPartCFrame = nil

-- Internal functions
local function cleanup()
    Csync._Enabled = false
    
    for _, connection in pairs(Csync._Connections) do 
        if connection and typeof(connection) == "RBXScriptConnection" then 
            connection:Disconnect() 
        end
    end
    
    for _, instance in pairs(Csync._Instances) do
        if instance and instance.Parent then 
            instance:Destroy() 
        end
    end
    
    for _, drawing in pairs(Csync._Drawings) do
        if drawing then 
            drawing:Remove() 
        end
    end
    
    table.clear(Csync._Connections)
    table.clear(Csync._Instances)
    table.clear(Csync._Drawings)
    table.clear(Csync._PositionHistory)
    
    if Csync._OriginalCFrameIndex then
        hookmetamethod(game, "__index", Csync._OriginalCFrameIndex)
        Csync._OriginalCFrameIndex = nil
    end
end

local function getPing()
    local networkPing = player:GetNetworkPing() * 1000
    
    local dataPing = 0
    local item = Stats.Network.ServerStatsItem:FindFirstChild("Data Ping")
    if item then
        local ok, v = pcall(function()
            return item:GetValueString()
        end)
        if ok and v then
            dataPing = tonumber(v:match("%d+")) or 0
        end
    end
    
    local totalPing = networkPing + dataPing
    
    if totalPing > Csync._Config.ServerPrediction.HighPingThreshold then
        networkPing = networkPing * Csync._Config.ServerPrediction.HighPingReduction
        totalPing = networkPing + dataPing
    end
    
    return math.min(totalPing, Csync._Config.ServerPrediction.MaxPing)
end

local function getPredictedServerPosition()
    if not Csync._Config.UseServerPrediction then
        return playerHumanoidRootPart.Position
    end
    
    local currentTime = tick()
    Csync._PositionHistory[currentTime] = {
        Position = playerHumanoidRootPart.Position,
        Rotation = playerHumanoidRootPart.Rotation
    }
    
    for time in pairs(Csync._PositionHistory) do
        if currentTime - time > Csync._Config.ServerPrediction.HistoryDuration then
            Csync._PositionHistory[time] = nil
        end
    end
    
    local ping = getPing()
    local backtrackTime = currentTime - (ping / 1000)
    
    local closestTime = nil
    local smallestDiff = math.huge
    
    for time, data in pairs(Csync._PositionHistory) do
        local diff = math.abs(time - backtrackTime)
        if diff < smallestDiff then
            smallestDiff = diff
            closestTime = time
        end
    end
    
    if closestTime and Csync._PositionHistory[closestTime] then
        return Csync._PositionHistory[closestTime].Position
    end
    
    return playerHumanoidRootPart.Position
end

local function createVisuals()
    if Csync._Instances.desyncVisual then 
        Csync._Instances.desyncVisual:Destroy() 
    end
    
    if Csync._Instances.imageGui then
        Csync._Instances.imageGui:Destroy()
    end
    
    if Csync._Drawings.line then
        Csync._Drawings.line:Remove()
    end
    
    if Csync._Drawings.lineOutline then
        Csync._Drawings.lineOutline:Remove()
    end

    if not Csync._Enabled then return end

    local randomNum = math.random(222, 4444)
    local visualType = Csync._Config.Visuals.VisualType
    
    local desyncVisual = nil
    
    if visualType == "Mesh" or visualType == "Both" then
        desyncVisual = Instance.new("Part")
        desyncVisual.Name = "CsyncVis_Mesh_" .. randomNum
        desyncVisual.Size = Vector3.new(0.1, 0.1, 0.1)
        desyncVisual.Color = Csync._Config.Visuals.DesyncColor
        desyncVisual.Material = Enum.Material.Neon
        desyncVisual.Transparency = Csync._Config.Visuals.Transparency
        desyncVisual.Anchored = true
        desyncVisual.CanCollide = false
        desyncVisual.CastShadow = false
        
        local specialMesh = Instance.new("SpecialMesh")
        specialMesh.MeshId = Csync._Config.Visuals.MeshId
        specialMesh.TextureId = "rbxassetid://14123716537"
        specialMesh.Scale = Csync._Config.Visuals.MeshScale
        specialMesh.Offset = Csync._Config.Visuals.MeshOffset
        specialMesh.MeshType = Enum.MeshType.FileMesh
        specialMesh.Parent = desyncVisual
        
        if Csync._Config.Visuals.Highlight.Enabled then
            local highlight = Instance.new("Highlight")
            highlight.Name = "CsyncHighlight"
            highlight.FillColor = Csync._Config.Visuals.Highlight.FillColor
            highlight.OutlineColor = Csync._Config.Visuals.Highlight.OutlineColor
            highlight.FillTransparency = Csync._Config.Visuals.Highlight.FillTransparency
            highlight.OutlineTransparency = Csync._Config.Visuals.Highlight.OutlineTransparency
            
            if Csync._Config.Visuals.Highlight.DepthMode == "AlwaysOnTop" then
                highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
            else
                highlight.DepthMode = Enum.HighlightDepthMode.Occluded
            end
            
            highlight.Parent = desyncVisual
            Csync._Instances.highlight = highlight
        end

        desyncVisual.Parent = workspace
        Csync._Instances.desyncVisual = desyncVisual
        Csync._Instances.specialMesh = specialMesh
    end
    
    if visualType == "Image" or visualType == "Both" then
        local screenGui = Instance.new("ScreenGui")
        screenGui.Name = "CsyncUI_" .. randomNum
        screenGui.ResetOnSpawn = false
        screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
        
        local frame = Instance.new("Frame")
        frame.Name = "ImageContainer"
        frame.Size = UDim2.new(0, 100 * Csync._Config.Visuals.ImageScale, 
                                0, 100 * Csync._Config.Visuals.ImageScale)
        frame.BackgroundTransparency = 1
        frame.AnchorPoint = Vector2.new(0.5, 0.5)
        frame.Parent = screenGui
        
        local imageLabel = Instance.new("ImageLabel")
        imageLabel.Name = "CsyncImage"
        imageLabel.Size = UDim2.new(1, 0, 1, 0)
        imageLabel.Position = UDim2.new(0.5, 0, 0.5, 0)
        imageLabel.AnchorPoint = Vector2.new(0.5, 0.5)
        imageLabel.BackgroundTransparency = 1
        imageLabel.Image = Csync._Config.Visuals.ImageId
        imageLabel.ScaleType = Enum.ScaleType.Fit
        imageLabel.Parent = frame
        
        screenGui.Parent = CoreGui
        
        Csync._Instances.imageGui = screenGui
        Csync._Instances.imageFrame = frame
        Csync._Instances.imageLabel = imageLabel
    end

    if Csync._Config.Visuals.ShowLine then
        local lineOutline = Drawing.new("Line")
        lineOutline.Thickness = Csync._Config.Visuals.Line.OutlineThickness
        lineOutline.Color = Csync._Config.Visuals.Line.OutlineColor
        lineOutline.Transparency = Csync._Config.Visuals.Line.OutlineTransparency
        lineOutline.Visible = true
        
        local line = Drawing.new("Line")
        line.Thickness = Csync._Config.Visuals.Line.MainThickness
        line.Color = Csync._Config.Visuals.Line.MainColor
        line.Transparency = Csync._Config.Visuals.Line.MainTransparency
        line.Visible = true
        
        Csync._Drawings.lineOutline = lineOutline
        Csync._Drawings.line = line
    end
    
    return true
end

local function updateLines()
    if not Csync._Config.Visuals.ShowLine then 
        if Csync._Drawings.line then
            Csync._Drawings.line.Visible = false
        end
        if Csync._Drawings.lineOutline then
            Csync._Drawings.lineOutline.Visible = false
        end
        return 
    end
    
    if not Csync._Drawings.line or not Csync._Drawings.lineOutline then return end
    
    local line = Csync._Drawings.line
    local lineOutline = Csync._Drawings.lineOutline
    
    local visualExists = false
    local visualPosition = nil
    
    if Csync._Instances.desyncVisual then
        visualExists = true
        visualPosition = Csync._Instances.desyncVisual.Position
    end
    
    if Csync._Enabled and playerHumanoidRootPart and visualExists then
        local realPos = playerHumanoidRootPart.Position
        
        local realScreenPos, realVisible = Camera:WorldToViewportPoint(realPos)
        local desyncScreenPos, desyncVisible = Camera:WorldToViewportPoint(visualPosition)
        
        if realVisible and desyncVisible then
            local fromPos = Vector2.new(realScreenPos.X, realScreenPos.Y)
            local toPos = Vector2.new(desyncScreenPos.X, desyncScreenPos.Y)
            
            local direction = (toPos - fromPos)
            local length = direction.Magnitude
            
            if length > 0 then
                local normalizedDir = direction / length
                local extension = Csync._Config.Visuals.Line.Extension
                local outlineFrom = fromPos - (normalizedDir * extension)
                local outlineTo = toPos + (normalizedDir * extension)
                
                lineOutline.From = outlineFrom
                lineOutline.To = outlineTo
                lineOutline.Visible = true
                
                line.From = fromPos
                line.To = toPos
                line.Visible = true
            else
                lineOutline.Visible = false
                line.Visible = false
            end
        else
            lineOutline.Visible = false
            line.Visible = false
        end
    else
        lineOutline.Visible = false
        line.Visible = false
    end
end

local function updateImagePosition()
    if not Csync._Enabled then return end
    if not Csync._Instances.imageGui then return end
    if not Csync._Instances.desyncVisual then return end
    
    local desyncPos = Csync._Instances.desyncVisual.Position
    local screenPoint = Camera:WorldToScreenPoint(desyncPos)
    
    Csync._Instances.imageFrame.Position = UDim2.new(0, screenPoint.X, 0, screenPoint.Y)
end

-- Public API Functions

-- Main toggle function
function Csync(state)
    if state == nil then
        Csync._Enabled = not Csync._Enabled
    else
        Csync._Enabled = state
    end
    
    if Csync._Enabled then
        createVisuals()
        -- Start connections if not already started
        if not Csync._Connections.heartbeat then
            Csync._Connections.characterAdded = player.CharacterAdded:Connect(function(NewCharacter)
                playerCharacter = NewCharacter
                playerHumanoid = playerCharacter:WaitForChild("Humanoid")
                playerHumanoidRootPart = playerCharacter:WaitForChild("HumanoidRootPart")
                
                if Csync._Enabled then
                    createVisuals()
                end
            end)
            
            Csync._Connections.heartbeat = RunService.Heartbeat:Connect(function(deltaTime)
                if playerCharacter and playerHumanoidRootPart then
                    playerHumanoidRootPartCFrame = playerHumanoidRootPart.CFrame
                    
                    local basePosition = getPredictedServerPosition()
                    
                    local currentX = Csync._Enabled and Csync._Config.Position.X or 0
                    local currentY = Csync._Enabled and Csync._Config.Position.Y or 0
                    local currentZ = Csync._Enabled and Csync._Config.Position.Z or 0
                    
                    -- Check for locked position
                    if Csync._LockPosition and tick() < Csync._LockUntil then
                        currentX = Csync._LockPosition.X
                        currentY = Csync._LockPosition.Y
                        currentZ = Csync._LockPosition.Z
                    end
                    
                    local desyncedPosition = basePosition + Vector3.new(
                        currentX,
                        currentY,
                        currentZ
                    )
                    
                    if Csync._Instances.desyncVisual then
                        Csync._Instances.desyncVisual.CFrame = CFrame.new(desyncedPosition) * playerHumanoidRootPart.CFrame.Rotation
                    end
                    
                    playerHumanoidRootPart.CFrame = CFrame.new(desyncedPosition) * playerHumanoidRootPart.CFrame.Rotation
                    RunService.RenderStepped:Wait()
                    playerHumanoidRootPart.CFrame = playerHumanoidRootPartCFrame
                    playerHumanoidRootPartCFrame = playerHumanoidRootPart.CFrame
                end
            end)
            
            Csync._Connections.renderStepped = RunService.RenderStepped:Connect(function()
                updateLines()
                updateImagePosition()
            end)
            
            -- Hook CFrame for other scripts
            Csync._OriginalCFrameIndex = hookmetamethod(game, "__index", function(Instance, Property)
                if playerCharacter and playerHumanoidRootPart and Instance == playerHumanoidRootPart and Property == "CFrame" then
                    if not checkcaller() then
                        return playerHumanoidRootPartCFrame
                    end
                end
                return Csync._OriginalCFrameIndex(Instance, Property)
            end)
        end
    else
        -- Clean up visuals but keep connections for quick re-enabling
        if Csync._Instances.desyncVisual then
            Csync._Instances.desyncVisual:Destroy()
            Csync._Instances.desyncVisual = nil
        end
        if Csync._Instances.imageGui then
            Csync._Instances.imageGui:Destroy()
            Csync._Instances.imageGui = nil
        end
        if Csync._Drawings.line then
            Csync._Drawings.line:Remove()
            Csync._Drawings.line = nil
        end
        if Csync._Drawings.lineOutline then
            Csync._Drawings.lineOutline:Remove()
            Csync._Drawings.lineOutline = nil
        end
    end
end

-- Set desync position
function CsyncPos(x, y, z)
    if not Csync._Enabled then
        warn("Csync must be enabled to set position. Use Csync(true) first.")
        return
    end
    
    if type(x) == "number" and type(y) == "number" and type(z) == "number" then
        Csync._Config.Position.X = x
        Csync._Config.Position.Y = y
        Csync._Config.Position.Z = z
    elseif type(x) == "number" and y == nil and z == nil then
        Csync._Config.Position.X = x
    elseif type(x) == "number" and type(y) == "number" and z == nil then
        Csync._Config.Position.X = x
        Csync._Config.Position.Y = y
    end
end

-- Lock position for specific time
function CsyncSetLockPos(x, y, z, duration)
    if not Csync._Enabled then
        warn("Csync must be enabled to set locked position. Use Csync(true) first.")
        return
    end
    
    Csync._LockPosition = Vector3.new(x, y, z)
    Csync._LockUntil = tick() + (duration or 5)
    
    -- Auto unlock after duration
    if duration then
        task.delay(duration, function()
            Csync._LockPosition = nil
        end)
    end
end

-- Set keybind
function CsyncKeybindSet(key)
    if Csync._Connections.inputBegan then
        Csync._Connections.inputBegan:Disconnect()
    end
    
    local keyCode
    if type(key) == "string" then
        keyCode = Enum.KeyCode[key:upper()]
    elseif typeof(key) == "EnumItem" then
        keyCode = key
    end
    
    if keyCode then
        Csync._Keybind = keyCode
        Csync._Connections.inputBegan = UserInputService.InputBegan:Connect(function(input, gameProcessed)
            if not gameProcessed and input.KeyCode == keyCode then
                Csync(not Csync._Enabled)
            end
        end)
    end
end

-- Line visibility
function CsyncLine(state)
    Csync._Config.Visuals.ShowLine = state
    if not state then
        if Csync._Drawings.line then
            Csync._Drawings.line.Visible = false
        end
        if Csync._Drawings.lineOutline then
            Csync._Drawings.lineOutline.Visible = false
        end
    end
end

-- Set line color
function CsyncLineColorSet(r, g, b)
    if type(r) == "number" and type(g) == "number" and type(b) == "number" then
        Csync._Config.Visuals.Line.MainColor = Color3.fromRGB(r, g, b)
        if Csync._Drawings.line then
            Csync._Drawings.line.Color = Color3.fromRGB(r, g, b)
        end
    end
end

-- Set visual type
function CsyncVisualType(type)
    local validTypes = {"Mesh", "Image", "Both", "None"}
    if table.find(validTypes, type) then
        Csync._Config.Visuals.VisualType = type
        if Csync._Enabled then
            createVisuals()
        end
    else
        warn("Invalid visual type. Use: Mesh, Image, Both, or None")
    end
end

-- Toggle highlight
function CsyncHighlight(state)
    Csync._Config.Visuals.Highlight.Enabled = state
    if Csync._Instances.highlight then
        Csync._Instances.highlight.Enabled = state
    elseif state and Csync._Enabled and Csync._Instances.desyncVisual then
        -- Create highlight if it doesn't exist
        local highlight = Instance.new("Highlight")
        highlight.Name = "CsyncHighlight"
        highlight.FillColor = Csync._Config.Visuals.Highlight.FillColor
        highlight.OutlineColor = Csync._Config.Visuals.Highlight.OutlineColor
        highlight.FillTransparency = Csync._Config.Visuals.Highlight.FillTransparency
        highlight.OutlineTransparency = Csync._Config.Visuals.Highlight.OutlineTransparency
        
        if Csync._Config.Visuals.Highlight.DepthMode == "AlwaysOnTop" then
            highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        else
            highlight.DepthMode = Enum.HighlightDepthMode.Occluded
        end
        
        highlight.Parent = Csync._Instances.desyncVisual
        Csync._Instances.highlight = highlight
    end
end

-- Set mesh
function CsyncSetMesh(meshId, scale, offset)
    if meshId then
        Csync._Config.Visuals.MeshId = meshId
    end
    if scale then
        Csync._Config.Visuals.MeshScale = scale
    end
    if offset then
        Csync._Config.Visuals.MeshOffset = offset
    end
    
    if Csync._Instances.specialMesh then
        Csync._Instances.specialMesh.MeshId = Csync._Config.Visuals.MeshId
        Csync._Instances.specialMesh.Scale = Csync._Config.Visuals.MeshScale
        Csync._Instances.specialMesh.Offset = Csync._Config.Visuals.MeshOffset
    end
end

-- Set image
function CsyncSetImage(imageId, scale)
    if imageId then
        Csync._Config.Visuals.ImageId = imageId
    end
    if scale then
        Csync._Config.Visuals.ImageScale = scale
    end
    
    if Csync._Instances.imageLabel then
        Csync._Instances.imageLabel.Image = Csync._Config.Visuals.ImageId
    end
    if Csync._Instances.imageFrame then
        Csync._Instances.imageFrame.Size = UDim2.new(0, 100 * Csync._Config.Visuals.ImageScale, 
                                                      0, 100 * Csync._Config.Visuals.ImageScale)
    end
end

-- Get current state
function CsyncGetState()
    return {
        Enabled = Csync._Enabled,
        Position = Vector3.new(Csync._Config.Position.X, Csync._Config.Position.Y, Csync._Config.Position.Z),
        Locked = tick() < Csync._LockUntil,
        LockPosition = Csync._LockPosition,
        LockRemaining = math.max(0, Csync._LockUntil - tick()),
        Keybind = Csync._Keybind
    }
end

-- Toggle server prediction
function CsyncPrediction(state)
    Csync._Config.UseServerPrediction = state
end

-- Destroy/Cleanup
function CsyncDestroy()
    cleanup()
end

-- Initialize keybind
CsyncKeybindSet(Csync._Keybind)

-- Return module
return setmetatable(Csync, {
    __call = function(self, ...)
        return Csync(...)
    end
})
